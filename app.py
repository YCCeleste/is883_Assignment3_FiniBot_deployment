# Import necessary libraries
import streamlit as st
import openai
import os
from io import StringIO
import pandas as pd
import streamlit as st


# Make sure to add your OpenAI API key in the advanced settings of streamlit's deployment
open_AI_key = os.environ.get('OPENAI_API_KEY')
openai.api_key = open_AI_key


### Here, with some adjustments, copy-paste the code you developed for Question 1 in Assignment 3 
##########################################################################
# -*- coding: utf-8 -*-
"""Copy of Assignment3_Celeste.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10ujtl_HTKDUmrBJ-XYn-KxPRdunyLTOG

#Using `LangChain` for Prompt Engineering

##Q0: Loading OpenAI API key
"""

!pip install openai==0.28.1

from google.colab import drive
drive.mount('/content/drive/')

config_ini_location = '/content/drive/MyDrive/IS883/config_new1.ini' # Change this to point to the location of your config.ini file.

import configparser

config = configparser.ConfigParser()
config.read(config_ini_location)
openai_api_key = config['OpenAI']['API_KEY']

"""## Q1: FiniBot, financial advising simplified!

As we have seen in class, breaking a prompt down into chains is useful and, if engineered well, returns better and more reliably responses.

[In class](https://github.com/elhamod/IS883/blob/main/Prompt_Engineering_Agents.ipynb), we have seen the most basic form of chains, a `SequentialChain`. However, other more sophisticated chains exist. Here, you will explore a [`RouterChain`](https://python.langchain.com/docs/modules/chains/foundational/router#legacy-routerchain). This chain acts like a switch. Given a condition, it decided which prompt to use. This is in contrast to the deterministic sequantial nature of `SequentialChain`.

Using `RouterChain`, and in a manner similar to [`LangChain` in-class demo](https://github.com/elhamod/IS883/blob/main/Prompt_Engineering_Agents.ipynb), write a solution for the following scenario:

-----------------------------------
You are creating a financial advising ChatBot, FiniBot. Yor clients will fill out [the following csv file](https://docs.google.com/spreadsheets/d/1wJHJE7hrXcedpk9bTQ0oulwTTs41wu32TPTw0FebwXw/edit?usp=sharing), which contains a cell for savings, another for monthly debt, and finally a cell for monthly income. You ChatBot will
 1. Download the file as an `.csv` to your Google Drive.
 2. Load the file to the notebook.
 3. Based on the content of the file, describe your client's situation objectively and in one of two levels: "Novice" and "Expert".
 4. Based on the client's situation:
 - If your client's [debt ratio](https://www.investopedia.com/ask/answers/081214/whats-considered-be-good-debttoincome-dti-ratio.asp#:~:text=Lenders%2C%20including%20anyone%20who%20might,lenders%20prefer%2036%25%20or%20below.) is less than 0.3, then FiniBot will commend the client's financial accomplishment and then turn into an investment advisor. It will advise to invest their money and provide them with an investment portfolio based on their savings and using 5 stocks.
 - Otherwise, FiniBot will politely and cautiously, without taking them on a guilt trip, warn the client about their financial situation. It will then turn into a debt advisor, and create a plan for them to pay off their debt by allocating 10% of their income for monthly debt payments.
---------------------------------------

The final output of your code should be (as text):
---------------------------
<pre>
 - Total savings:  < value >
 - Monthly debt: < value >
 - Monthly income: < value >

 - Financial situation:
 < Your ChatBots Financial summary in "Novice" or "Expert" tone >

- Recommendation:
 < Your advisor's output >
 </pre>
-----------------
"""

!pip install langchain

"""Step 1: Load the `.csv` file as text. You can use [`CSVLoader`](https://python.langchain.com/docs/integrations/document_loaders/csv)"""

csv_path = "/content/drive/MyDrive/IS883/Assignment/Assignment3/IS883_Assignment3_FiniBot - Sheet1.csv"

def loadCSVFile(csv_path):

  from langchain.document_loaders.csv_loader import CSVLoader

  # Create a CSVLoader instance
  loader = CSVLoader(csv_path)

  # Load the content of the CSV file
  data = loader.load()

  return data[0].page_content

# printing the content of the file
text = loadCSVFile(csv_path)
print(text)

import re

# Extracting numbers from the input
numbers = re.findall(r'\$([0-9,]+\.\d{2})', text)
numbers = [float(num.replace(',', '')) for num in numbers]

debt_ratio = numbers[1]/numbers[2]

# Include the debt ratio in the 'text' variable
text += f"\nDebt Ratio: {debt_ratio}"

print(text)

"""Here, define `Output_template`, the text that contains the formatted output message as described above. This template has `{input}` as input string. Assume that `{input}` contains the final variables of interest: the input savings, debt, income, and output summary."""

from langchain.prompts import PromptTemplate


# Output template
Output_template= """

- Total savings: extract savings in {input} as Total savings
- Monthly debt: extract the credit card debt in {input} as Monthly debt
- Monthly income: assume the income is monthly income so extract income in {input} as Monthly income

- Financial situation:
Give a financial situation based on debt ratio

- Recommendation:
Provide a recommendation
"""

"""Here define the `investmet_template`, which should act as the prompt template used when the investment advisor is selected. This template has {input} as input string. Assume that {input} contains the final variables of interest: the input savings, debt, income, and output summary."""

investment_template = """

Based on data in {input},
The client's debt ratio is < 0.3

Turn client into our excellent investment advisors and provide a suggestion on investment porfolio based on your savings and using 5 stocks.


""" + Output_template

"""Here define the `debt_template`, which should act as the prompt template used when the debt advisor is selected. This template has {input} as input string. Assume that {input} contains the final variables of interest: the input savings, debt, income, and output summary."""

debt_template = """


Based on data in {input},
We've noticed that your financial situation requires some attention.

In order to improve your financial health, I will turn you into our excellent debt advisors.
Our excellent debt advisor will help you to create a plan with allocationg 10% of your income for monthly debt payments.

""" + Output_template

"""Here, define the two possible routes that can be taken as described above. Follow the example shown [here](https://python.langchain.com/docs/modules/chains/foundational/router#legacy-routerchain).
Each branch should define the **name** of the route, its **description** (which will be used to select the route), and the **template** that will be used for that route.
"""

routes = [
    {
        "name": "investment advisor",
        "description": "This is used when the client's debt ratio is < 0.3",
        "prompt_template": investment_template,
    },
    {
        "name": "debt advisor",
        "description": "This is used when the client's debt ratio is >= 0.3",
        "prompt_template": debt_template,
    },
]

"""Here, define the variable that sets the `level` of the returned summary."""

level= "Novice"

"""Create the `langchain.llms.OpenAI` language model. name it `llm`. As you progress with your assignment, consider what appropriate [parameters](https://api.python.langchain.com/en/latest/llms/langchain.llms.openai.OpenAI.html) to use here."""

from langchain.chat_models import ChatOpenAI
llm = ChatOpenAI(api_key=openai_api_key, model = 'gpt-4', temperature= 0.3)

"""**Answer:**

We can adjust the temperature setting. Lower temperatures yield more predictable results, while higher temperatures foster creativity. Therefore, if we aim for consistent outcomes in providing the text of financial situations and suggestions in each attempt, a lower temperature setting is preferable but not lower to 0. Additionally, experimenting with different models can enhance results. For instance, transitioning from GPT-3.5 to GPT-4 may lead to improvements.

Create a destination chain for each possible route. Follow the example shown [here](https://python.langchain.com/docs/modules/chains/foundational/router#legacy-routerchain).
"""

from langchain import PromptTemplate, LLMChain, ConversationChain

destination_chains = {}
for route in routes:
    name = route["name"]
    prompt_template = route["prompt_template"]
    prompt = PromptTemplate(template=prompt_template, input_variables=["input"])
    chain = LLMChain(llm=llm, prompt=prompt)  # Include output_key here
    destination_chains[name] = chain

# If you want a default chain
default_chain = ConversationChain(llm=llm, output_key="text")

"""Create a `financial_prompt` for summarizing the client's situation. Include the client's financial knowledge `{level}` as a parameter in this template.
- Make sure to use the prompt engineering tips we used in class. You may find [these tips](https://pbs.twimg.com/media/F0RWXIjXgAARNAG?format=jpg&name=4096x4096) useful.
- Make sure your prompt is talking the client as a chatbot, and not in 3rd person.
"""

financial_prompt = """

You are a financial expert.
If the debt ratio is < 0.30 please use "investment advisor"; otherwiese, go to "debt advisor"
And please use {level} to summarize client's situation, including client's debt ratio
"""
financial_prompt = PromptTemplate.from_template(financial_prompt)

"""This template is needed by `RouterChain`."""

MULTI_PROMPT_ROUTER_TEMPLATE = """\
Given a raw text input to a language model select the model prompt best suited for \
the input. You will be given the names of the available prompts and a description of \
what the prompt is best suited for. You may also revise the original input if you \
think that revising it will ultimately lead to a better response from the language \
model.

<< FORMATTING >>
Return a markdown code snippet with a JSON object formatted to look like:
```json
{{{{
    "destination": string \\ name of the prompt to use or "DEFAULT"
    "next_inputs": string \\ a modified version of the original input. It is modified to contai only: the "savings" value, the "debt" value, the "income" value, and the "summary" provided above.
}}}}
```

REMEMBER: "destination" MUST be one of the candidate prompt names specified below OR \
it can be "DEFAULT" if the input is not well suited for any of the candidate prompts.
REMEMBER: "next_inputs" is not the original input. It is modified to contain: the "savings" value, the "debt" value, the "income" value, and the "summary" provided above.

<< CANDIDATE PROMPTS >>
{destinations}

<< INPUT >>
{{input}}

<< OUTPUT (must include ```json at the start of the response) >>
<< OUTPUT (must end with ```) >>
"""

"""The following code creates the routing template"""

prompt = financial_prompt + MULTI_PROMPT_ROUTER_TEMPLATE

from langchain.chains.router.llm_router import LLMRouterChain, RouterOutputParser
from langchain.chains.router.multi_prompt_prompt import MULTI_PROMPT_ROUTER_TEMPLATE

destinations = [f"{route['name']}: {route['description']}" for route in routes]
destinations_str = "\n".join(destinations)
router_template = MULTI_PROMPT_ROUTER_TEMPLATE.format(destinations=destinations_str)

from langchain.chains.router.llm_router import LLMRouterChain, RouterOutputParser

router_prompt = PromptTemplate(
    template=router_template,
    input_variables=["input"],
    output_parser=RouterOutputParser(),
)
print(router_prompt.template)
router_chain = LLMRouterChain.from_llm(llm, router_prompt)

from langchain.chains.router import MultiPromptChain
from langchain.chains import ConversationChain

chain = MultiPromptChain(
    router_chain=router_chain,
    destination_chains=destination_chains,
    default_chain=ConversationChain(llm=llm, output_key="text"),
    verbose=True,
)

print(chain.run(text))

"""Now, try it! Write a code that:
- Turns `langchain.debug` on so you could see what it going on.
- Runs the `chain` we created above.
"""

from IPython.utils import text
import langchain

# Turn on debug mode
langchain.debug = True

# Execute the MultiPromptChain
result = chain.run(text)

# Print the result
print(result)

"""Answer the following questions:



1.   Iteratively improve your code and prompts until you achieve the desired output.

  - Enumerate and describe the steps the chain is taking to produce the final output by taking a look at the debugging output.
  - Does the final output match expectation? If not, what are the "bugs" from the client's perspective and what's your justification for their occurance?
  - What "extra mile" you could have gone to improve results?

**Answer:**

- ***First try***: Initially, I set each variable as {savings}, {debt}, {income}. However, it did not connect to the chain and did not provide any output text.

- ***Second try***: After transforming {savings}, {debt}, {income} into {input}, it is connected to the chain and starts to provide output text, but with the wrong text title. For example, the output text should be "- Monthly income," but it provided me with "- Annual income."

- ***Third try***: I used more specific words from the output template. For example, "extract the credit card debt in {input} as Monthly debt." Then this problem was fixed. Another problem was that the chain did not determine which template to use even though I asked the financial model to do the debt ratio calculation.

- ***Fourth try***: I added one more step: I extract the result from the original {input}, which is CSV file, and do the debt ratio calculation. Besides, I add it to the {input}, which I add as "debt ratio" as a variable.

- ***Finally***: **The final output matches expectations!**

 However, the result of final output is not stable. For example, sometimes the model viewed income as annual income, then divided it into 12. When this happened, the model went into the debt advisor route. Therefore, the **"extra mile"** I can take is to make the model more stable.

2. With the final chain, for each of the following scenarios, run the `chain` 10 times to sample the spectrum of generated answers:

*   A `csv` where the debt is `$500` and the savings are `$4,000`, with a monthly income of `$4,000`
*   A `csv` where the debt is `$500` and the savings are `$0`, with a monthly income of `$4,000`
*   A `csv` where the debt is `$1,500` and the savings are `$4,000`, with an monthly income of `$3,000`
"""

def run10times(csv_file):
  text = loadCSVFile(csv_path)
  numbers = re.findall(r'\$([0-9,]+\.\d{2})', text)
  numbers = [float(num.replace(',', '')) for num in numbers]

  debt_ratio = numbers[1]/numbers[2]
  text += f"\nDebt Ratio: {debt_ratio}"
  for _ in range(10):
        chain = MultiPromptChain(
            router_chain=router_chain,
            destination_chains=destination_chains,
            default_chain=ConversationChain(llm=llm, output_key="text"),
            verbose=True,
        )
        print(chain.run(text))

## Call for first scenario
csv_path = "/content/drive/MyDrive/IS883/Assignment/Assignment3/IS883_Assigment3_data1 - Sheet1.csv"
run10times(csv_path)

## Call for second scenario
csv_path = "/content/drive/MyDrive/IS883/Assignment/Assignment3/IS883_Assigment3_data2 - Sheet1.csv"
run10times(csv_path)

## Call for third scenario
csv_path = "/content/drive/MyDrive/IS883/Assignment/Assignment3/IS883_Assigment3_data3 - Sheet1.csv"
run10times(csv_path)

"""- State the expected correct output for each scenario in your own words.
- What was the success rate for each scenario (as a percentage)? How did you calculate it?
- Can you explain the low or high rate of success for each scenario? Comment, with suggestions when appropriate, on your findings.

**Answer:**

-   ***Scenario 1***

      **Expected correct output** :

      - Total savings: $4,000.00
      - Monthly debt:  $500.00
      - Monthly income: $4,000.00
      - Financial situation:
        Congratulations! Your debt ratio is 0.125, which is excellent. You can consider investing your income.

      - Recommendation:
        Our recommendation is to invest your money on 5 stocks. For further information, please contact our investment advisor.
      
      **Success rate** : 100%, Having the correct debt ratio, and providing 5 stocks to invest means success.  

      **Low or High success rate** :
      Although the model might provide different portfolios for investing in stocks, the success rate is really high.

-   ***Scenario 2***

      **Expected correct output** :

      - Total savings: $0.00
      - Monthly debt:  $500.00
      - Monthly income: $4,000.00
      - Financial situation:
        Congratulations! Your debt ratio is an excellent 0.125. However, currently, you don't have savings. We recommend putting 50% of your monthly income into savings and investing the rest
      - Recommendation:
        Our recommendation is for you to consider putting 50% of your monthly income into savings and investing the rest in five stocks. For more information, please contact our investment advisor.
      
      **Success rate** : 90%, If the model suggests that the client should build an emergency fund first and then start investing monthly in five stocks, it is considered successful.

      **Low or High success rate** :
      One of results did not mention build an emergency fund first. However, it still has 90% success rate.

-   ***Scenario 3***

      **Expected correct output** :

      - Total savings: $4,000.00
      - Monthly debt:  $1,500.00
      - Monthly income: $3,000.00
      - Financial situation:
        Your debt ratio is 0.50. Although you have $4,000 in Savings, you still need to pay attention to this high debt rate.
      - Recommendation:
        Our recommendation is to allocate 10% of your monthly income and focus on high-interest debts. Allocate more of the 10% to these debts, paying the minimum on others.
      
      **Success rate** : 100%, Having the correct debt ratio and creating a plan for them to pay off their debt by allocating 10% of their income for monthly payments means success.

      **Low or High success rate** :
        The success rate is really high and the result is stable.

##Q2 (BONUS): FiniBot is online!

You are now ready to start offering FiniBot services to the public! Here is what you need to do:

Create a User interface using `streamlit` that consists of:
- An `st.header` containing text welcoming your client and asking them to upload the spreadsheet. Provide a link to the spreadsheet's template in this header.
- An [`st.file_uploader`](https://docs.streamlit.io/library/api-reference/widgets/st.file_uploader) "Upload spreadsheet" button. [This](https://stackoverflow.com/questions/68248125/how-to-read-csv-file-from-user-in-streamlit-and-converting-to-pandas-dataframe) may also be useful.
- An [`st.radio`](https://docs.streamlit.io/library/api-reference/widgets/st.radio) toggle button to select whether the client is a "Novice" or an "Expert".
- Displays the spreadsheet neatly, like [this](https://stackoverflow.com/questions/68248125/how-to-read-csv-file-from-user-in-streamlit-and-converting-to-pandas-dataframe).
- An `st.markdown` to output FiniBot's analysis and recommendation.

You may find [this cheatsheet](https://cheat-sheet.streamlit.app/) helpful while you are constructing your UI.

To create the app, follow these steps:

1. Fork the [following GitHub](https://github.com/elhamod/is883_Assignment3). You will be filling your code inside `app.py`
2. Develop `streamlit`'s code as described above. You do not need to have language modeling at this point yet. You only need to have a functioning UX.
3. Copy the code you have developed in Q1 to `app.py` and integrate it with `streamlit`'s code ***appropriately***. You will have to make some adjustments (e.g., getting the level from the toggle button rather than hard-coding it).
4. Commit, push, and deploy!

Here are some guides for working with Streamlit's community cloud:

- For getting started and signing up (please follow only the first 8 steps): [Streamlit Community Cloud Quickstart](https://docs.streamlit.io/streamlit-community-cloud/get-started/quickstart)
- For deploying from your GitHub repository: [Deploying to Streamlit Cloud](https://docs.streamlit.io/streamlit-community-cloud/deploy-your-app)
- Make sure to add `OPENAI_API_KEY` in advanced settings
"""



##########################################################################


# UX goes here. You will have to encorporate some variables from the code above and make some tweaks.
def load_data(file):
    data = pd.read_excel(file)  # Assuming it's an Excel file, adjust as needed
    return data

def display_spreadsheet(data):
    st.dataframe(data)

def finibot_analysis(data, client_type):
    # Add your FiniBot analysis and recommendation logic here
    # For simplicity, let's assume the analysis is a simple message
    if client_type == "Novice":
        result = "FiniBot recommends focusing on building an emergency fund first."
    else:
        result = "FiniBot suggests optimizing your debt allocation and investing strategy."

    return result

def main():
    st.header("Welcome to FiniBot!")

    st.markdown("Please upload your financial spreadsheet using the button below.")
    template_link = "[Spreadsheet Template](insert_template_link_here)"
    st.markdown(f"Download the template spreadsheet here: {template_link}")

    uploaded_file = st.file_uploader("Upload spreadsheet", type=["csv", "xlsx"])

    if uploaded_file is not None:
        client_type = st.radio("Select your client type:", ["Novice", "Expert"])

        # Load and display the spreadsheet
        data = load_data(uploaded_file)
        display_spreadsheet(data)

        # FiniBot analysis and recommendation
        result = finibot_analysis(data, client_type)
        st.markdown(f"**FiniBot's Recommendation:**\n{result}")

if __name__ == "__main__":
    main()



